# Clean Photo Storage Design

## API Endpoint Changes

### Endpoints to Remove

1. GET `/api/memories/photos/{photoId}/view-authenticated`

   - Currently serves photos directly
   - Will be replaced by new photo retrieval endpoint
   - Reason: Need to handle both temp and permanent states

2. POST `/api/memories/{memoryId}/photos`
   - Currently links photos to memory immediately
   - Will be replaced by canvas save transaction
   - Reason: Photos should only be linked when canvas is saved

### Endpoints to Keep & Modify

1. POST `/api/memories/photos`
   - Rename to: POST `/api/photos/upload`
   - Reuse existing upload logic
   - Add: Sets initial state='N'
   - Add: Stores in temp_photos directory

## Storage Structure

```
/workspace/server/file_storage/
├── temp_photos/         # Temporary storage (N state)
│   └── {uuid}.jpg      # Photos not yet saved to any canvas
└── photos/             # Permanent storage (P state)
    └── {uuid}.jpg      # Photos saved with canvas
```

## New API Structure

1. Photo Upload (Modified existing endpoint)

```
POST /api/photos/upload
Request: multipart/form-data with photo
Response: {
    id: uuid,
    state: "N"
}
```

2. Photo Retrieval (New endpoint)

```
GET /api/photos/retrieve/{id}?state=N|P
Response: photo binary data
Authorization: Verified based on state
```

3. Canvas Save (Handles photo linking)

```
POST /api/memories/{id}/save
Request: {
    photos: [
        { id: uuid, state: "N" },  // New photos to save
        { id: uuid, state: "P" },  // Existing photos to keep
        { id: uuid, state: "R" }   // Photos to remove
    ],
    ...other canvas data
}
```

### Database Schema

```sql
-- Photos Table
CREATE TABLE photos (
    id UUID PRIMARY KEY,
    file_path VARCHAR(1024) NOT NULL,
    state CHAR(1) NOT NULL CHECK (state IN ('N', 'P', 'R')),
    user_id INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- Memory Photos Link Table
CREATE TABLE memory_photos (
    memory_id INTEGER REFERENCES memories(id) ON DELETE CASCADE,
    photo_id UUID REFERENCES photos(id) ON DELETE CASCADE,
    position JSONB NOT NULL DEFAULT '{}',
    PRIMARY KEY (memory_id, photo_id)
);
```

### Core Operations

1. Photo Upload (Modified)

```
- Generate UUID
- Save to temp_photos/
- Create photo record with state='N'
```

2. Canvas Save

```sql
BEGIN TRANSACTION
    -- Handle new photos (N -> P)
    FOR each N state photo:
        Move file from temp_photos/ to photos/
        Update photo state to 'P'
        Create memory_photos link

    -- Handle removed photos (P -> R)
    FOR each R state photo:
        Remove memory_photos link
        Update photo state to 'R'
        Queue cleanup job

    -- Update memory
    Update memory data
COMMIT
```

3. Photo Cleanup

```sql
BEGIN TRANSACTION
    -- Find photos marked R with no memory links
    SELECT p.id, p.file_path
    FROM photos p
    LEFT JOIN memory_photos mp ON p.id = mp.photo_id
    WHERE p.state = 'R'
    AND mp.memory_id IS NULL

    FOR each photo:
        Delete file
        Delete photo record
COMMIT
```

### Data Integrity

1. File Operations:

   - Only after successful DB transactions
   - Clear cleanup on failures

2. State Transitions:

   - N -> P: When saving with canvas
   - P -> R: When removing from canvas
   - R -> DELETE: When no more canvas references

3. Authorization:
   - N state: Only uploading user
   - P state: Users with canvas access
   - R state: No access

### Background Jobs

1. Cleanup Job:

   - Runs periodically (e.g., hourly)
   - Removes R state photos with no links
   - Deletes both DB record and file

2. Temp Cleanup:
   - Runs daily
   - Removes old N state photos (>24h)
   - Cleans temp_photos/ directory
